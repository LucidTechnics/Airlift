var res = require('airlift/resource');
var util = require('airlift/util');

var context = {};
var web = {};
var bediako = {};

exports.setUp = function()
{
	bediako.id = "6524d6f79d19"
	bediako.fullName = "Bediako George";
	bediako.shortName = "Bedi";
	bediako.status = "middle aged";
	bediako.birthDate = new Packages.java.util.Date(new Date('01/01/1970').getTime());
	bediako.age = 43;

	bediako.friendList = new Packages.java.util.ArrayList();
	bediako.friendList.add("friend1");
	bediako.friendList.add("friend2");
	bediako.friendList.add("friend3");
	
	bediako.enemySet = new Packages.java.util.HashSet();
	bediako.enemySet.add("enemy1");
	bediako.enemySet.add("enemy2");

	context.resourceName = 'person';

	//person resource metadata generated by AirliftLabs Person dictation ...
	context.resourceMetadata = require('airlift/ResourceMetadata').create({ persistable:true, securable:true, presentable:true });
	context.resourceMetadata.name = 'person';
	context.resourceMetadata.attributes = ['fullName', 'shortName', 'status', 'birthDate', 'age', 'friendList', 'enemySet', 'auditPostDate', 'auditPutDate', 'auditUserId', 'id'];

	//person attributes metadata generated by Airlift Labs Person
	//dictation
	var MetaData = function()
	{
		this.resourceName = 'person';
		this.attributes = {};
		this.foreignKeys = [];

		this.attributes['fullName'] = require('airlift/AttributeMetadata').create({ name:"fullName", type:"java.lang.String", isIndexable:true, displayOrder:10, label:"full name" }); 
		this.attributes['shortName'] = require('airlift/AttributeMetadata').create({ name:"shortName", type:"java.lang.String", isIndexable:true, displayOrder:20, label:"short name" }); 
		this.attributes['status'] = require('airlift/AttributeMetadata').create({ name:"status", type:"java.lang.String", displayOrder:30, label:"status", allowedValues:{ "senior": 1,"middle aged": 1,"youth": 1 } }); 
		this.attributes['birthDate'] = require('airlift/AttributeMetadata').create({ name:"birthDate", type:"java.util.Date", isIndexable:true, displayOrder:40, label:"birth date" }); 
		this.attributes['age'] = require('airlift/AttributeMetadata').create({ name:"age", type:"java.lang.Integer", isIndexable:true, displayOrder:50, label:"age" }); 
		this.attributes['friendList'] = require('airlift/AttributeMetadata').create({ name:"friendList", type:"java.util.List<java.lang.String>", isIndexable:true, displayOrder:60, label:"friend list" }); 
		this.attributes['enemySet'] = require('airlift/AttributeMetadata').create({ name:"enemySet", type:"java.util.Set<java.lang.String>", isIndexable:true, displayOrder:70, label:"enemy set" }); 
		this.attributes['auditPostDate'] = require('airlift/AttributeMetadata').create({ name:"auditPostDate", type:"java.util.Date", isSearchable:true, isIndexable:true, nullable:true, label:"record created date" }); 
		this.attributes['auditPutDate'] = require('airlift/AttributeMetadata').create({ name:"auditPutDate", type:"java.util.Date", isSearchable:true, isIndexable:true, nullable:true, label:"record updated date" }); 
		this.attributes['auditUserId'] = require('airlift/AttributeMetadata').create({ name:"auditUserId", type:"java.lang.String", nullable:true, label:"changed by user id", isPresentable:false }); 
		this.attributes['id'] = require('airlift/AttributeMetadata').create({ name:"id", type:"java.lang.String", isPrimaryKey:true, displayOrder:0, label:"record id" }); 
	}

	context.attributesMetadata = new MetaData();
	context.attributes = context.resourceMetadata.attributes;
	context.WEB_CONTEXT = {}; //not needed for unit tests ...
};

exports['test each'] = function(_assert)
{
	var attributes = [];
	
	res.each('person', bediako, function(_value, _attributeName, _resource)
	{
		attributes.push(_attributeName);

		_assert.eq(bediako, _resource, 'resource is not the resource provided to each');
		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.errorReporter), 'error reporter should have a value');
		_assert.eq(true, util.hasValue(this.errorReporter.report), 'error reporter should have a report function');
		_assert.eq(true, util.hasValue(this.attributesMetadata), 'attributes metadata should have a value');
		_assert.eq(false, util.isEmpty(this.attributesMetadata), 'attributes metadata should not be empty');
		_assert.eq(this.attributesMetadata.attributes[_attributeName].name, _attributeName, 'attribute metadata for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.resourceMetadata), 'resource meta data should have a value');
		_assert.eq(false, util.isEmpty(this.resourceMetadata), 'resource meta data should not be empty');
		_assert.eq(this.resourceMetadata.name, 'person', 'resource has wrong name');
		
	}, context);

	_assert.deepEqual(attributes, context.attributes, 'attribute list is not correct');
};

exports['test map'] = function(_assert)
{
	var attributes = [];

	//create a person resource using map ...
	var person = res.map('person', bediako, function(_value, _attributeName, _resource)
	{
		attributes.push(_attributeName);

		_assert.eq(bediako, _resource, 'resource is not the resource provided to each');
		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.errorReporter), 'error reporter should have a value');
		_assert.eq(true, util.hasValue(this.errorReporter.report), 'error reporter should have a report function');
		_assert.eq(true, util.hasValue(this.attributesMetadata), 'attributes metadata should have a value');
		_assert.eq(false, util.isEmpty(this.attributesMetadata), 'attributes metadata should not be empty');
		_assert.eq(this.attributesMetadata.attributes[_attributeName].name, _attributeName, 'attribute metadata for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.resourceMetadata), 'resource meta data should have a value');
		_assert.eq(false, util.isEmpty(this.resourceMetadata), 'resource meta data should not be empty');
		_assert.eq(this.resourceMetadata.name, 'person', 'resource has wrong name');

		return _value;

	}, context);

	_assert.deepEqual(attributes, context.attributes, 'attribute list is not correct');

	//test that the person resource is the same as the bediako resource ...
	res.each('person', person, function(_value, _attributeName, _resource)
	{
		attributes.push(_attributeName);

		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

	}, context);
};

exports['test reduce'] = function(_assert)
{
	var attributes = [];
	
	var reducedResult = res.reduce('person:', 'person', bediako, function(_base, _value, _attributeName, _resource)
	{
		attributes.push(_attributeName);

		_assert.eq(bediako, _resource, 'resource is not the resource provided to each');
		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.errorReporter), 'error reporter should have a value');
		_assert.eq(true, util.hasValue(this.errorReporter.report), 'error reporter should have a report function');
		_assert.eq(true, util.hasValue(this.attributesMetadata), 'attributes metadata should have a value');
		_assert.eq(false, util.isEmpty(this.attributesMetadata), 'attributes metadata should not be empty');
		_assert.eq(this.attributesMetadata.attributes[_attributeName].name, _attributeName, 'attribute metadata for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.resourceMetadata), 'resource meta data should have a value');
		_assert.eq(false, util.isEmpty(this.resourceMetadata), 'resource meta data should not be empty');
		_assert.eq(this.resourceMetadata.name, 'person', 'resource has wrong name');

		return _base + ':' + _attributeName + '=' + _value;		
	}, context);

	_assert.eq("person::fullName=Bediako George:shortName=Bedi:status=middle aged:birthDate=Thu Jan 01 00:00:00 EST 1970:age=43:friendList=[friend1, friend2, friend3]:enemySet=[enemy2, enemy1]:auditPostDate=undefined:auditPutDate=undefined:auditUserId=undefined:id=6524d6f79d19",
			   reducedResult, 'unexpected reduced result');
};

exports['test sequence'] = function(_assert)
{
	var results = [];
	
	var sequence = res.sequence(
	 function() { results.push(1); },
	 function() { results.push(2); },
	 function() { results.push(3); },
	 function() { results.push(4); }
	);

	sequence();

	_assert.deepEqual([1,2,3,4], results, 'all functions did not appear to run in sequence');

	var attributes = [];
	
	res.each('person', bediako, res.sequence(function(_value, _attributeName, _resource)
	{
		attributes.push(_attributeName);

		_assert.eq(bediako, _resource, 'resource is not the resource provided to each');
		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.errorReporter), 'error reporter should have a value');
		_assert.eq(true, util.hasValue(this.errorReporter.report), 'error reporter should have a report function');
		_assert.eq(true, util.hasValue(this.attributesMetadata), 'attributes metadata should have a value');
		_assert.eq(false, util.isEmpty(this.attributesMetadata), 'attributes metadata should not be empty');
		_assert.eq(this.attributesMetadata.attributes[_attributeName].name, _attributeName, 'attribute metadata for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.resourceMetadata), 'resource meta data should have a value');
		_assert.eq(false, util.isEmpty(this.resourceMetadata), 'resource meta data should not be empty');
		_assert.eq(this.resourceMetadata.name, 'person', 'resource has wrong name');

	}), context);

	_assert.deepEqual(attributes, context.attributes, 'attribute list is not correct');
};

exports['test compose'] = function(_assert)
{
	var results = [];

	var compose = res.compose(
	  function() { results.push(1); },
	  function() { results.push(2); },
	  function() { results.push(3); },
	  function() { results.push(4); }
	);

	compose();

	_assert.deepEqual([4,3,2,1], results, 'all functions did not appear to run in composition');

	var attributes = [];

	res.each('person', bediako, res.compose(function(_value, _attributeName, _resource)
	{
		attributes.push(_attributeName);

		_assert.eq(bediako, _resource, 'resource is not the resource provided to each');
		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.errorReporter), 'error reporter should have a value');
		_assert.eq(true, util.hasValue(this.errorReporter.report), 'error reporter should have a report function');
		_assert.eq(true, util.hasValue(this.attributesMetadata), 'attributes metadata should have a value');
		_assert.eq(false, util.isEmpty(this.attributesMetadata), 'attributes metadata should not be empty');
		_assert.eq(this.attributesMetadata.attributes[_attributeName].name, _attributeName, 'attribute metadata for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.resourceMetadata), 'resource meta data should have a value');
		_assert.eq(false, util.isEmpty(this.resourceMetadata), 'resource meta data should not be empty');
		_assert.eq(this.resourceMetadata.name, 'person', 'resource has wrong name');

	}), context);

	_assert.deepEqual(attributes, context.attributes, 'attribute list is not correct');
};

exports['test watch'] = function(_assert)
{
	var executionTest = [], attributes = {};
	
	var watch = res.watch('birthDate', 'age', function(_value, _attributeName, _resource)
	{
		executionTest.push(1);

		attributes[_attributeName] = (attributes[_attributeName] && attributes[_attributeName] + 1)||1;

		_assert.eq(bediako, _resource, 'resource is not the resource provided to each');
		_assert.eq(bediako[_attributeName], _value, 'value for: ' + _attributeName + ' is not correct');
		_assert.eq(bediako[_attributeName], _resource[_attributeName], 'resource attribute value for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.errorReporter), 'error reporter should have a value');
		_assert.eq(true, util.hasValue(this.errorReporter.report), 'error reporter should have a report function');
		_assert.eq(true, util.hasValue(this.attributesMetadata), 'attributes metadata should have a value');
		_assert.eq(false, util.isEmpty(this.attributesMetadata), 'attributes metadata should not be empty');
		_assert.eq(this.attributesMetadata.attributes[_attributeName].name, _attributeName, 'attribute metadata for: ' + _attributeName + ' is not correct');

		_assert.eq(true, util.hasValue(this.resourceMetadata), 'resource meta data should have a value');
		_assert.eq(false, util.isEmpty(this.resourceMetadata), 'resource meta data should not be empty');
		_assert.eq(this.resourceMetadata.name, 'person', 'resource has wrong name');
	});

	res.each('person', bediako, watch, context);

	var result = {age: 1};
	
	_assert.deepEqual(result, attributes, 'wrong attributes visited before watch execution');
	_assert.eq(1, executionTest.length, 'watch allowed execution to occur more than once.');
};

exports['test copy'] = function(_assert)
{
	var target = {};
	
	res.each('person', bediako, res.copy.partial(target), context);

	_assert.eq(bediako.id, target.id, 'id not equal');
	_assert.eq(bediako.fullName, target.fullName, 'fullName not equal');
	_assert.eq(bediako.shortName, target.shortName, 'shortName not equal');
	_assert.eq(bediako.status, target.status, 'status not equal');
	_assert.eq(bediako.birthDate, target.birthDate, 'birthDate not equal');
	_assert.eq(bediako.age, target.age, 'age not equal');
	_assert.eq(bediako.friendList, target.friendList, 'friendList not equal');
	_assert.eq(bediako.enemySet, target.enemySet, 'enemySet not equal');
};

exports['test clone'] = function(_assert)
{
	var target = res.map('person', bediako, res.clone, context);

	_assert.eq(bediako.id, target.id, 'id not equal');
	_assert.eq(bediako.fullName, target.fullName, 'fullName not equal');
	_assert.eq(bediako.shortName, target.shortName, 'shortName not equal');
	_assert.eq(bediako.status, target.status, 'status not equal');
	_assert.eq(bediako.birthDate, target.birthDate, 'birthDate not equal');
	_assert.eq(bediako.age, target.age, 'age not equal');
	_assert.eq(bediako.friendList, target.friendList, 'friendList not equal');
	_assert.eq(bediako.enemySet, target.enemySet, 'enemySet not equal');
};
